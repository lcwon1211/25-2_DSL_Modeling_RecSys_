# -*- coding: utf-8 -*-
"""triple.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cmvd0dejXSbxsBTcW7MDIBeXGSzKBEph
"""

import pandas as pd
import numpy as np
import os

# --------------------------------------------------------------------------
# 헬퍼 함수 (지표 계산을 위해 재사용)
# --------------------------------------------------------------------------
def robust_minmax(x: pd.Series, q_low=0.05, q_high=0.95) -> pd.Series:
    """로버스트 정규화 함수"""
    x = pd.to_numeric(x, errors='coerce')
    lo, hi = x.quantile(q_low), x.quantile(q_high)
    rng = max(hi - lo, 1e-12)
    return ((x - lo) / rng).clip(0, 1)

def _safe_mean(df: pd.DataFrame, cols):
    """데이터프레임의 여러 열의 평균을 안전하게 계산하는 함수"""
    cols = [c for c in cols if c in df.columns]
    if not cols: return pd.Series(0.0, index=df.index)
    return df[cols].astype(float).fillna(0.0).mean(axis=1)

def _coerce_binary(s: pd.Series) -> pd.Series:
    """결측값을 0으로 취급하여 이진(0 또는 1) 값으로 변환하는 함수"""
    s = pd.to_numeric(s, errors='coerce').fillna(0.0)
    return (s > 0).astype(float)

# --------------------------------------------------------------------------
# 1단계: 경로(Route) 트리플 생성 함수
# --------------------------------------------------------------------------
def generate_route_triples(route_info: pd.DataFrame) -> list:
    """경로 데이터를 분석하여 지식그래프 트리플을 생성합니다."""

    print("경로 특징 지표를 계산합니다...")
    R = route_info.copy()

    # --- 복합 개념 지표 계산 ---
    for c in ['difficulty_score', 'uphill_share', 'downhill_share', 'flat_share']:
        if c in R.columns: R[c+'_norm'] = robust_minmax(R[c])
    if 'flat_share_norm' in R.columns: R['flat_share_inv'] = 1.0 - R['flat_share_norm']
    diff_parts = [c for c in ['difficulty_score_norm','uphill_share_norm', 'downhill_share_norm','flat_share_inv'] if c in R.columns]
    R['difficulty_index'] = _safe_mean(R, diff_parts)

    for c in ['night_safe_mean','night_safe_min','bright_share']:
        if c in R.columns: R[c+'_norm'] = robust_minmax(R[c])
    safe_parts = [c for c in ['night_safe_mean_norm','night_safe_min_norm','bright_share_norm'] if c in R.columns]
    R['safety_index'] = _safe_mean(R, safe_parts)

    if 'crossing_score' in R.columns:
        R['crossing_score_norm'] = robust_minmax(R['crossing_score'])
    else:
        R['crossing_score_norm'] = 0.0

    triples = []
    direct_feature_map = {
        'has_park': 'has_feature:Park', 'has_waterside': 'has_feature:Waterside',
        'has_subway': 'has_feature:Subway', 'has_store': 'has_feature:Store',
        'has_toilet': 'has_feature:Toilet'
    }

    print("경로 트리플 생성을 시작합니다...")
    for _, row in R.iterrows():
        route_id_str = f"Route_{int(row['route_id'])}"

        for col, predicate in direct_feature_map.items():
            if col in row and _coerce_binary(pd.Series(row[col])).iloc[0] == 1.0:
                triples.append((route_id_str, predicate, 'Yes'))

        if row['difficulty_index'] > 0.66: triples.append((route_id_str, 'has_property:Difficulty', 'High'))
        elif row['difficulty_index'] < 0.33: triples.append((route_id_str, 'has_property:Difficulty', 'Low'))
        else: triples.append((route_id_str, 'has_property:Difficulty', 'Medium'))

        if row['safety_index'] > 0.7: triples.append((route_id_str, 'has_property:Safety', 'High'))
        if row['crossing_score_norm'] > 0.8: triples.append((route_id_str, 'has_flaw:Many_Crossings', 'Yes'))

    return triples

# --------------------------------------------------------------------------
# 2단계: 사용자(User) 트리플 생성 함수
# --------------------------------------------------------------------------
def generate_user_triples(output: pd.DataFrame) -> list:
    """사용자 설문 데이터를 분석하여 지식그래프 트리플을 생성합니다."""
    U = output.copy()
    triples = []
    preference_feature_map = {
        'park': 'Feature:Park', 'green': 'Feature:Green', 'river': 'Feature:River',
        'fountin': 'Feature:Fountain', 'subway': 'Feature:Subway',
        'cvs': 'Feature:CVS', 'toilet': 'Feature:Toilet'
    }
    purpose_cols = ['dc_stress', 'getting_fit', 'marathon', 'physical_improv']

    print("사용자 트리플 생성을 시작합니다...")
    for _, row in U.iterrows():
        user_id_str = f"User_{int(row['user_id'])}"

        for purpose in purpose_cols:
            if purpose in row and _coerce_binary(pd.Series(row[purpose])).iloc[0] == 1.0:
                persona = purpose.replace('_', ' ').title()
                triples.append((user_id_str, 'is_a:Persona', persona))
                break

        if 'conv_no' not in row or row['conv_no'] != 1:
            for col, feature_obj in preference_feature_map.items():
                if col in row and _coerce_binary(pd.Series(row[col])).iloc[0] == 1.0:
                    triples.append((user_id_str, 'prefers', feature_obj))

        if 'day_or_night' in row:
            time_of_day = str(row['day_or_night']).title()
            triples.append((user_id_str, 'runs_at:Time', time_of_day))

        if 'level' in row:
            level_map = {0: 'Low', 1: 'Medium-Low', 2: 'Medium-High', 3: 'High'}
            slope_pref = level_map.get(row['level'], 'Unknown')
            triples.append((user_id_str, 'prefers_slope:Level', slope_pref))

    return triples

# --------------------------------------------------------------------------
# 3단계: 사용자-경로 상호작용 트리플 생성 함수
# --------------------------------------------------------------------------
def generate_interaction_triples(
    rankings_df: pd.DataFrame,
    top_k_positive: int = 1000,   # <-- 100개에서 1000개로 수정
    bottom_k_negative: int = 2000 # <-- 긍정 샘플의 2배로 설정
) -> list:
    """사용자별 경로 순위 데이터를 바탕으로 '좋아요'/'싫어요' 트리플을 생성합니다."""

    print("사용자-경로 상호작용 트리플 생성을 시작합니다...")
    triples = []

    # 'wide' 포맷 데이터를 'long' 포맷으로 변환
    rankings_long = rankings_df.melt(
        id_vars=['user_id'],
        var_name='rank_str',
        value_name='route_id'
    ).dropna()
    rankings_long['rank'] = pd.to_numeric(rankings_long['rank_str'].str.replace('rank_', ''))

    total_ranks = rankings_long['rank'].max()

    # 각 사용자별로 긍정/부정 샘플링
    for user_id, group in rankings_long.groupby('user_id'):
        user_id_str = f"User_{int(user_id)}"

        # 긍정 샘플 (상위 K개)
        positive_samples = group[group['rank'] <= top_k_positive]
        for _, row in positive_samples.iterrows():
            route_id_str = f"Route_{int(row['route_id'])}"
            triples.append((user_id_str, 'likes', route_id_str))

        # 부정 샘플 (하위 K개)
        negative_samples = group[group['rank'] > total_ranks - bottom_k_negative]
        for _, row in negative_samples.iterrows():
            route_id_str = f"Route_{int(row['route_id'])}"
            triples.append((user_id_str, 'dislikes', route_id_str))

    return triples

# --------------------------------------------------------------------------
# 4단계: 메인 실행
# --------------------------------------------------------------------------
if __name__ == '__main__':
    route_info_path = 'df_route_capped_normalized.csv'
    user_info_path = 'output4(in).csv'
    user_rankings_path = 'user_preferred_route.csv' # 사용자 선호도 파일
    output_filename = 'kg_triples_final.csv'

    # 1. 데이터 불러오기
    try:
        route_info = pd.read_csv(route_info_path)
        user_info = pd.read_csv(user_info_path)
        user_rankings = pd.read_csv(user_rankings_path)
        print("모든 원본 파일을 성공적으로 불러왔습니다.\n")
    except FileNotFoundError as e:
        print(f"오류: 파일을 찾을 수 없습니다. 경로를 확인하세요. -> {e}")
        exit()

    # 2. 각 소스에서 트리플 생성
    route_triples = generate_route_triples(route_info)
    print(f"\n경로 트리플 {len(route_triples)}개 생성 완료.\n")

    user_triples = generate_user_triples(user_info)
    print(f"\n사용자 트리플 {len(user_triples)}개 생성 완료.\n")

    # 수정된 샘플링 개수로 상호작용 트리플 생성
    interaction_triples = generate_interaction_triples(user_rankings)
    print(f"\n상호작용 트리플 {len(interaction_triples)}개 생성 완료.\n")

    # 3. 모든 트리플 결합 및 저장
    all_triples = route_triples + user_triples + interaction_triples

    kg_df = pd.DataFrame(all_triples, columns=['subject', 'predicate', 'object'])

    kg_df.to_csv(output_filename, index=False)

    print("="*50)
    print(f"최종 지식그래프 트리플이 '{output_filename}' 파일로 저장되었습니다.")
    print(f"총 트리플 개수: {len(kg_df)}")
    print("="*50)
    print("\n생성된 트리플 샘플:")
    print(kg_df.sample(n=10, random_state=1))
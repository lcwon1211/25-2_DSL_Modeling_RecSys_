# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rzi1PcQ3prIhxh98GdHhnm6gaAt46Dgm
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
import random
import time

SEED = 42
random.seed(SEED)
np.random.seed(SEED)
torch.manual_seed(SEED)
torch.cuda.manual_seed_all(SEED)

# ==========================
# 1. 데이터 로드
# ==========================
user_df = pd.read_csv("/content/drive/MyDrive/modeling/output4.csv")
pref_df = pd.read_csv("/content/drive/MyDrive/modeling/pf_route.csv")
route_df = pd.read_csv("/content/drive/MyDrive/modeling/df_route_capped_normalized.csv")
pref_df.rename(columns={pref_df.columns[0]: "user_id"}, inplace=True)

# wide → long 변환
long_pref = pref_df.melt(id_vars="user_id", var_name="rank", value_name="route_id")
long_pref["rank"] = long_pref["rank"].str.replace("rank_", "").astype(int)
long_pref = long_pref.dropna(subset=["route_id"])

# rank ≤ 100만 사용
long_pref = long_pref[long_pref["rank"] <= 1000]

# ==========================
# 2. ID 매핑 (0-based)
# ==========================
user2idx = {uid: i for i, uid in enumerate(user_df["user_id"].unique())}
route2idx = {rid: i for i, rid in enumerate(route_df["route_id"].unique())}
idx2user  = {i: uid for uid, i in user2idx.items()}
idx2route = {i: rid for rid, i in route2idx.items()}

user_df["user_id"] = user_df["user_id"].map(user2idx)
route_df["route_id"] = route_df["route_id"].map(route2idx)
long_pref["user_id"] = long_pref["user_id"].map(user2idx)
long_pref["route_id"] = long_pref["route_id"].map(route2idx)

long_pref = long_pref.dropna(subset=["user_id","route_id"]).astype({"user_id":int, "route_id":int})
long_pref.head()

# ==========================
# 3. feature & scaling
# ==========================
user_numeric_cols = ['level','hope2run','pc_scenery']
user_binary_cols  = ['park','day_or_night','green',
 'scene_no',
 'river',
 'conv_no',
 'fountin',
 'subway',
 'cvs',
 'toilet',
 'dc_stress',
 'getting_fit',
 'marathon',
 'physical_improv']

# route
route_numeric_cols = [
    'total_length','num_edges','night_safe_mean','night_safe_min',
    'bright_share','mean_deficit','difficulty_score','uphill_share',
    'downhill_share','flat_share'
]
route_binary_cols = ['has_park','has_waterside','has_subway','has_store','has_toilet']

# float 로 만들어주기
def coerce_float(df, cols):
    if not cols:
        return df
    df[cols] = df[cols].apply(pd.to_numeric, errors="coerce")
    df[cols] = df[cols].fillna(0).astype(float)
    return df

user_df  = coerce_float(user_df, user_numeric_cols + user_binary_cols)
route_df = coerce_float(route_df, route_numeric_cols + route_binary_cols)

# ---------- 6. 스케일링 ----------
scaler_user  = StandardScaler()
scaler_route = StandardScaler()
if user_numeric_cols:
    user_df[user_numeric_cols] = scaler_user.fit_transform(user_df[user_numeric_cols])
if route_numeric_cols:
    route_df[route_numeric_cols] = scaler_route.fit_transform(route_df[route_numeric_cols])

# ---------- 7. User-based Split (train/valid/test = 6:2:2) ----------
users = user_df["user_id"].unique()
train_users, temp_users = train_test_split(users, test_size=0.4, random_state=SEED)
valid_users, test_users = train_test_split(temp_users, test_size=0.5, random_state=SEED)

train_pos = long_pref[long_pref["user_id"].isin(train_users)].copy()
valid_pos = long_pref[long_pref["user_id"].isin(valid_users)].copy()
test_pos  = long_pref[long_pref["user_id"].isin(test_users)].copy()

import random
# ---------- 8. Negative Sampling (유저별 비선호 일부 샘플) ----------
ALL_ROUTE_IDS = route_df["route_id"].unique()
ALL_ROUTE_SET = set(ALL_ROUTE_IDS)

def sample_negative(pos_df, n_neg_per_user=200, seed=SEED):
    rng = np.random.default_rng(seed)
    rows = []
    for uid, grp in pos_df.groupby("user_id"):
        pos_routes = set(grp["route_id"].tolist())
        neg_candidates = np.array(list(ALL_ROUTE_SET - pos_routes))
        if len(neg_candidates) > 0 and n_neg_per_user > 0:
            take = min(n_neg_per_user, len(neg_candidates))
            neg_samples = rng.choice(neg_candidates, size=take, replace=False)
        else:
            neg_samples = np.array([], dtype=int)
        # positive
        for rid in pos_routes:
            rows.append((uid, rid, 1.0))
        # negative
        for rid in neg_samples:
            rows.append((uid, int(rid), 0.0))
    return pd.DataFrame(rows, columns=["user_id","route_id","label"])

train_df = sample_negative(train_pos, n_neg_per_user=4000, seed=SEED)
valid_df = sample_negative(valid_pos, n_neg_per_user=10000, seed=SEED)
# test는 랭킹 평가만 할 것이므로 positive만 필요
test_df  = test_pos.copy()

print(f"Train pairs: {len(train_df):,} | Valid pairs: {len(valid_df):,} | Test users: {len(test_users)}")

# ---------- 9. Dataset ----------
class UserRouteDataset(Dataset):
    def __init__(self, df, user_df, route_df):
        self.df = df.reset_index(drop=True)
        self.user_df = user_df.set_index("user_id")
        self.route_df = route_df.set_index("route_id")
    def __len__(self):
        return len(self.df)
    def __getitem__(self, idx):
        row = self.df.iloc[idx]
        uid, rid, label = int(row["user_id"]), int(row["route_id"]), float(row["label"])
        # user
        u_row = self.user_df.loc[uid]
        user_num = torch.tensor(pd.to_numeric(u_row[user_numeric_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32) if user_numeric_cols else torch.zeros(0, dtype=torch.float32)
        user_bin = torch.tensor(pd.to_numeric(u_row[user_binary_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32) if user_binary_cols else torch.zeros(0, dtype=torch.float32)
        # route (start node 제외)
        r_row = self.route_df.loc[rid]
        route_num = torch.tensor(pd.to_numeric(r_row[route_numeric_cols], errors="coerce").fillna(0).values,
                                 dtype=torch.float32) if route_numeric_cols else torch.zeros(0, dtype=torch.float32)
        route_bin = torch.tensor(pd.to_numeric(r_row[route_binary_cols], errors="coerce").fillna(0).values,
                                 dtype=torch.float32) if route_binary_cols else torch.zeros(0, dtype=torch.float32)
        return (
            torch.tensor(uid, dtype=torch.long),
            torch.tensor(rid, dtype=torch.long),
            user_num, user_bin,
            route_num, route_bin,
            torch.tensor(label, dtype=torch.float32)
        )

train_dataset = UserRouteDataset(train_df, user_df, route_df)
valid_dataset = UserRouteDataset(valid_df, user_df, route_df)

BATCH_SIZE = 512
train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True, drop_last=False)
valid_loader = DataLoader(valid_dataset, batch_size=BATCH_SIZE, shuffle=False, drop_last=False)

#모델
class UserTower(nn.Module):
    def __init__(self, user_vocab, num_numeric, num_binary, emb_dim=64, hidden=128, dropout=0.2):
        super().__init__()
        self.user_emb = nn.Embedding(user_vocab, emb_dim)
        self.num_linear = nn.Linear(max(1, num_numeric), emb_dim) if num_numeric > 0 else None
        self.bin_linear = nn.Linear(max(1, num_binary), emb_dim // 2) if num_binary > 0 else None
        in_dim = emb_dim + (emb_dim if self.num_linear else 0) + (emb_dim // 2 if self.bin_linear else 0)

        self.mlp = nn.Sequential(
            nn.Linear(in_dim, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, emb_dim)
        )

    def forward(self, user_id, user_num, user_bin):
        parts = [self.user_emb(user_id)]
        if self.num_linear:
            if user_num.ndim == 1:
                user_num = user_num.unsqueeze(0)
            parts.append(self.num_linear(user_num))
        if self.bin_linear:
            if user_bin.ndim == 1:
                user_bin = user_bin.unsqueeze(0)
            parts.append(self.bin_linear(user_bin))
        x = torch.cat(parts, dim=1)
        return F.normalize(self.mlp(x), dim=1)


class RouteTower(nn.Module):
    def __init__(self, route_vocab, num_numeric, num_binary, emb_dim=64, hidden=128, dropout=0.2):
        super().__init__()
        self.route_emb = nn.Embedding(route_vocab, emb_dim)
        self.num_linear = nn.Linear(max(1, num_numeric), emb_dim) if num_numeric > 0 else None
        self.bin_linear = nn.Linear(max(1, num_binary), emb_dim // 2) if num_binary > 0 else None
        in_dim = emb_dim + (emb_dim if self.num_linear else 0) + (emb_dim // 2 if self.bin_linear else 0)

        self.mlp = nn.Sequential(
            nn.Linear(in_dim, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, emb_dim)
        )

    def forward(self, route_id, route_num, route_bin):
        parts = [self.route_emb(route_id)]
        if self.num_linear:
            if route_num.ndim == 1:
                route_num = route_num.unsqueeze(0)
            parts.append(self.num_linear(route_num))
        if self.bin_linear:
            if route_bin.ndim == 1:
                route_bin = route_bin.unsqueeze(0)
            parts.append(self.bin_linear(route_bin))
        x = torch.cat(parts, dim=1)
        return F.normalize(self.mlp(x), dim=1)

def bce_loss(u_vec, r_vec, label, tau=0.05):
    """
    u_vec, r_vec : normalized embedding
    tau : temperature (작을수록 더 날카로운 분포)
    """
    logit = torch.sum(u_vec * r_vec, dim=1) / tau
    return F.binary_cross_entropy_with_logits(logit, label)

# ---------- 11. 학습 준비 ----------
device = "cuda" if torch.cuda.is_available() else "cpu"
user_tower  = UserTower(user_vocab=len(user2idx),
                        num_numeric=len(user_numeric_cols),
                        num_binary=len(user_binary_cols)).to(device)
route_tower = RouteTower(route_vocab=len(route2idx),
                         num_numeric=len(route_numeric_cols),
                         num_binary=len(route_binary_cols)).to(device)

optimizer = torch.optim.Adam(list(user_tower.parameters()) + list(route_tower.parameters()), lr=1e-4)


def info_nce_loss(u_vec, r_vec, tau=0.05):
    """
    InfoNCE loss: 배치 내에서 positive pair는 diagonal, 나머지는 negative
    u_vec: (B, d)
    r_vec: (B, d)
    """
    # similarity matrix (B, B)
    sim_matrix = torch.matmul(u_vec, r_vec.T) / tau

    # target: 각 row의 정답은 diagonal (0..B-1)
    target = torch.arange(sim_matrix.size(0), device=sim_matrix.device)

    return F.cross_entropy(sim_matrix, target)

# ---------- 12. 학습 루프 (valid는 pair-BCE + ranking 지표 둘 다 가능) ----------
def eval_ranking(users_subset, K=100):
    """전체 3.8만 루트 후보에서 Top-K를 뽑아 Hit@K와 Recall@K(정의대로)를 계산."""
    user_tower.eval(); route_tower.eval()
    # 모든 route embedding 1회 계산
    with torch.no_grad():
        all_rid = torch.tensor(route_df["route_id"].values, dtype=torch.long, device=device)
        all_rnum = torch.tensor(route_df[route_numeric_cols].values, dtype=torch.float32, device=device) if route_numeric_cols else torch.zeros((len(route_df),0), device=device)
        all_rbin = torch.tensor(route_df[route_binary_cols].values, dtype=torch.float32, device=device) if route_binary_cols else torch.zeros((len(route_df),0), device=device)
        all_rvec = route_tower(all_rid, all_rnum, all_rbin)  # (N_routes, d)

    hits, recalls = [], []
    with torch.no_grad():
        for uid in users_subset:
            # 유저 feature 불러와 벡터 생성
            urow = user_df[user_df["user_id"] == uid].iloc[0]
            unum = torch.tensor(pd.to_numeric(urow[user_numeric_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32, device=device) if user_numeric_cols else torch.zeros(0, device=device)
            ubin = torch.tensor(pd.to_numeric(urow[user_binary_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32, device=device) if user_binary_cols else torch.zeros(0, device=device)
            uvec = user_tower(torch.tensor([uid], dtype=torch.long, device=device),
                              unum.unsqueeze(0) if unum.ndim==1 else unum,
                              ubin.unsqueeze(0) if ubin.ndim==1 else ubin)  # (1,d)

            # 전체 루트 점수
            scores = torch.matmul(uvec, all_rvec.T).squeeze(0)  # (N_routes,)
            topk_idx = torch.topk(scores, K).indices.detach().tolist()
            topk_routes = set([int(idx) for idx in topk_idx])  # idx == route_id (매핑된 index)

            # 정답(그 유저의 Top100; test 또는 valid positive)
            if uid in test_users:
                true_routes = set(test_pos[test_pos["user_id"] == uid]["route_id"].tolist())
            else:
                true_routes = set(valid_pos[valid_pos["user_id"] == uid]["route_id"].tolist())

            # Hit@K (하나라도 맞으면 1)
            hit = 1.0 if len(topk_routes & true_routes) > 0 else 0.0
            hits.append(hit)
            # Recall@K (|교집합| / |정답집합|)
            recalls.append(len(topk_routes & true_routes) / max(1, len(true_routes)))
    return float(np.mean(hits)), float(np.mean(recalls))


EPOCHS   = 20
PATIENCE = 5
best_valid_hit = -1.0
no_improve = 0
K_EVAL = 10

for epoch in range(1, EPOCHS+1):
    user_tower.train(); route_tower.train()
    total_loss = 0.0
    t0 = time.time()
    for batch in train_loader:
        uid, rid, u_num, u_bin, r_num, r_bin, label = batch
        uid, rid = uid.to(device), rid.to(device)
        u_num, u_bin = u_num.to(device), u_bin.to(device)
        r_num, r_bin = r_num.to(device), r_bin.to(device)

        u_vec = user_tower(uid, u_num, u_bin)   # (B, d)
        r_vec = route_tower(rid, r_num, r_bin)  # (B, d)

        # InfoNCE loss 사용
        loss  = info_nce_loss(u_vec, r_vec, tau=0.05)

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        total_loss += loss.item()

    # --- validation ranking (전체 후보에서 평가) ---
    valid_hit, valid_recall = eval_ranking(valid_users, K=K_EVAL)
    print(f"[Epoch {epoch:02d}] TrainInfoNCE={total_loss/len(train_loader):.4f} | "
          f"Valid Hit@{K_EVAL}={valid_hit:.4f} | Valid Recall@{K_EVAL}={valid_recall:.4f} | "
          f"Time={time.time()-t0:.1f}s")

    if valid_hit > best_valid_hit:
        best_valid_hit = valid_hit
        no_improve = 0
        best_state = {
            "user_tower": user_tower.state_dict(),
            "route_tower": route_tower.state_dict(),
            "user2idx": user2idx, "route2idx": route2idx,
            "scaler_user": scaler_user, "scaler_route": scaler_route,
            "user_numeric_cols": user_numeric_cols, "route_numeric_cols": route_numeric_cols,
            "user_binary_cols": user_binary_cols, "route_binary_cols": route_binary_cols,
        }
    else:
        no_improve += 1
        if no_improve >= PATIENCE:
            print("Early stopping.")
            break

# ---------- 13. 최종 Test (전체 3.8만 루트 후보에서 평가) ----------
# 베스트 모델 로드
user_tower.load_state_dict(best_state["user_tower"])
route_tower.load_state_dict(best_state["route_tower"])
user_tower.eval(); route_tower.eval()

test_hit, test_recall = eval_ranking(test_users, K=1)
print(f"Final Test Hit@{K_EVAL} = {test_hit:.4f} | Final Test Recall@{K_EVAL} = {test_recall:.4f}")

# ---------- 14. (선택) 모델 저장 ----------
torch.save(best_state, "two_tower_no_startnode_gen2.pth")

# ==========================
# 1. Import
# ==========================
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import pandas as pd # Import pandas

# ==========================
# 2. 모델 정의
# ==========================
class UserTower(nn.Module):
    def __init__(self, user_vocab, num_numeric, num_binary, emb_dim=64, hidden=128):
        super().__init__()
        # test 유저도 index는 존재(전체 vocab)하지만 학습은 train 유저만 업데이트됨
        self.user_emb = nn.Embedding(user_vocab, emb_dim)
        self.num_linear = nn.Linear(max(1, num_numeric), emb_dim) if num_numeric > 0 else None
        self.bin_linear = nn.Linear(max(1, num_binary), emb_dim//2) if num_binary > 0 else None
        in_dim = emb_dim + (emb_dim if self.num_linear else 0) + (emb_dim//2 if self.bin_linear else 0)
        self.mlp = nn.Sequential(
            nn.Linear(in_dim, hidden),
            nn.ReLU(),
            nn.Linear(hidden, emb_dim)
        )
    def forward(self, user_id, user_num, user_bin):
        parts = [self.user_emb(user_id)]
        if self.num_linear:
            # Ensure user_num is at least 2D for linear layer
            if user_num.ndim == 1: user_num = user_num.unsqueeze(0)
            parts.append(self.num_linear(user_num))
        if self.bin_linear:
            # Ensure user_bin is at least 2D for linear layer
            if user_bin.ndim == 1: user_bin = user_bin.unsqueeze(0)
            parts.append(self.bin_linear(user_bin))
        x = torch.cat(parts, dim=1)
        return F.normalize(self.mlp(x), dim=1)

class RouteTower(nn.Module):
    def __init__(self, route_vocab, num_numeric, num_binary, emb_dim=64, hidden=128):
        super().__init__()
        self.route_emb = nn.Embedding(route_vocab, emb_dim)
        self.num_linear = nn.Linear(max(1, num_numeric), emb_dim) if num_numeric > 0 else None
        self.bin_linear = nn.Linear(max(1, num_binary), emb_dim//2) if num_binary > 0 else None
        in_dim = emb_dim + (emb_dim if self.num_linear else 0) + (emb_dim//2 if self.bin_linear else 0)
        self.mlp = nn.Sequential(
            nn.Linear(in_dim, hidden),
            nn.ReLU(),
            nn.Linear(hidden, emb_dim)
        )
    def forward(self, route_id, route_num, route_bin):
        parts = [self.route_emb(route_id)]
        if self.num_linear:
            # Ensure route_num is at least 2D for linear layer
            if route_num.ndim == 1: route_num = route_num.unsqueeze(0)
            parts.append(self.num_linear(route_num))
        if self.bin_linear:
            # Ensure route_bin is at least 2D for linear layer
            if route_bin.ndim == 1: route_bin = route_bin.unsqueeze(0)
            parts.append(self.bin_linear(route_bin))
        x = torch.cat(parts, dim=1)
        return F.normalize(self.mlp(x), dim=1)

# ==========================
# 3. 체크포인트 불러오기
# ==========================
checkpoint = torch.load(
    "two_tower_no_startnode_gen1.pth",
    map_location="cpu",
    weights_only=False
)

user2idx = checkpoint["user2idx"]
route2idx = checkpoint["route2idx"]
scaler_user = checkpoint["scaler_user"]
scaler_route = checkpoint["scaler_route"]
user_numeric_cols = checkpoint["user_numeric_cols"] # Load from checkpoint
user_binary_cols = checkpoint["user_binary_cols"] # Load from checkpoint
route_numeric_cols = checkpoint["route_numeric_cols"] # Load from checkpoint
route_binary_cols = checkpoint["route_binary_cols"] # Load from checkpoint


# ==========================
# 4. feature 개수 설정 (로드된 정보 사용)
# ==========================
num_numeric_user = len(user_numeric_cols)
num_binary_user  = len(user_binary_cols)
num_numeric_route = len(route_numeric_cols)
num_binary_route  = len(route_binary_cols)

user_vocab = len(user2idx)
route_vocab = len(route2idx)

# ==========================
# 5. 모델 초기화 + 로드
# ==========================
user_tower = UserTower(user_vocab, num_numeric_user, num_binary_user)
route_tower = RouteTower(route_vocab, num_numeric_route, num_binary_route)

user_tower.load_state_dict(checkpoint["user_tower"])
route_tower.load_state_dict(checkpoint["route_tower"])


user_tower.eval()
route_tower.eval()

# ==========================
# 6. 평가 함수 정의
# ==========================
device = "cuda" if torch.cuda.is_available() else "cpu"
def eval_ranking(users_subset, K=100):
    """전체 3.8만 루트 후보에서 Top-K를 뽑아 Hit@K와 Recall@K(정의대로)를 계산."""
    user_tower.eval(); route_tower.eval()
    # 모든 route embedding 1회 계산
    with torch.no_grad():
        # Ensure route_df exists and is accessible
        if 'route_df' not in globals():
            raise NameError("route_df is not defined. Please ensure the cell loading and preprocessing data has been run.")

        all_rid = torch.tensor(route_df["route_id"].values, dtype=torch.long, device=device)
        all_rnum = torch.tensor(route_df[route_numeric_cols].values, dtype=torch.float32, device=device) if route_numeric_cols else torch.zeros((len(route_df),0), device=device)
        all_rbin = torch.tensor(route_df[route_binary_cols].values, dtype=torch.float32, device=device) if route_binary_cols else torch.zeros((len(route_df),0), device=device)
        all_rvec = route_tower(all_rid, all_rnum, all_rbin)  # (N_routes, d)

    hits, recalls = [], []
    with torch.no_grad():
        for uid in users_subset:
            # Ensure user_df and test_pos exist and are accessible
            if 'user_df' not in globals() or 'test_pos' not in globals() or 'valid_pos' not in globals() or 'test_users' not in globals():
                 raise NameError("user_df, test_pos, valid_pos, or test_users are not defined. Please ensure the cells loading and splitting data have been run.")

            # 유저 feature 불러와 벡터 생성
            urow = user_df[user_df["user_id"] == uid].iloc[0]
            unum = torch.tensor(pd.to_numeric(urow[user_numeric_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32, device=device) if user_numeric_cols else torch.zeros(0, device=device)
            ubin = torch.tensor(pd.to_numeric(urow[user_binary_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32, device=device) if user_binary_cols else torch.zeros(0, device=device)
            uvec = user_tower(torch.tensor([uid], dtype=torch.long, device=device), unum.unsqueeze(0) if unum.ndim==1 else unum, ubin.unsqueeze(0) if ubin.ndim==1 else ubin)  # (1,d)

            # 전체 루트 점수
            scores = torch.matmul(uvec, all_rvec.T).squeeze(0)  # (N_routes,)
            topk_idx = torch.topk(scores, K).indices.detach().tolist()
            # Map indices back to original route_ids if necessary, or use mapped indices consistently
            topk_routes = set([int(idx) for idx in topk_idx])  # idx == route_id (매핑된 index)

            # 정답(그 유저의 Top100; test 또는 valid positive)
            if uid in test_users:
                true_routes = set(test_pos[test_pos["user_id"] == uid]["route_id"].tolist())
            else:
                true_routes = set(valid_pos[valid_pos["user_id"] == uid]["route_id"].tolist())

            # Hit@K (하나라도 맞으면 1)
            hit = 1.0 if len(topk_routes & true_routes) > 0 else 0.0
            hits.append(hit)
            # Recall@K (|교집합| / |정답집합|)
            recalls.append(len(topk_routes & true_routes) / max(1, len(true_routes)))
    return float(np.mean(hits)), float(np.mean(recalls))


# ==========================
# 7. 평가 실행 (예시)
# ==========================
# test_users, user_features, route_features 는 학습할 때 쓰던 split/구조와 동일하게 준비해야 함
test_hit, test_recall = eval_ranking(test_users, K=1)
print(f"Final Test Hit@10 = {test_hit:.4f}, Recall@10 = {test_recall:.4f}")

# ==========================
# 1. Import
# ==========================
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import pandas as pd # Import pandas

# ==========================
# 2. 모델 정의
# ==========================
class UserTower(nn.Module):
    def __init__(self, user_vocab, num_numeric, num_binary, emb_dim=64, hidden=128, dropout=0.2):
        super().__init__()
        self.user_emb = nn.Embedding(user_vocab, emb_dim)
        self.num_linear = nn.Linear(max(1, num_numeric), emb_dim) if num_numeric > 0 else None
        self.bin_linear = nn.Linear(max(1, num_binary), emb_dim // 2) if num_binary > 0 else None
        in_dim = emb_dim + (emb_dim if self.num_linear else 0) + (emb_dim // 2 if self.bin_linear else 0)

        self.mlp = nn.Sequential(
            nn.Linear(in_dim, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, emb_dim)
        )

    def forward(self, user_id, user_num, user_bin):
        parts = [self.user_emb(user_id)]
        if self.num_linear:
            if user_num.ndim == 1:
                user_num = user_num.unsqueeze(0)
            parts.append(self.num_linear(user_num))
        if self.bin_linear:
            if user_bin.ndim == 1:
                user_bin = user_bin.unsqueeze(0)
            parts.append(self.bin_linear(user_bin))
        x = torch.cat(parts, dim=1)
        return F.normalize(self.mlp(x), dim=1)


class RouteTower(nn.Module):
    def __init__(self, route_vocab, num_numeric, num_binary, emb_dim=64, hidden=128, dropout=0.2):
        super().__init__()
        self.route_emb = nn.Embedding(route_vocab, emb_dim)
        self.num_linear = nn.Linear(max(1, num_numeric), emb_dim) if num_numeric > 0 else None
        self.bin_linear = nn.Linear(max(1, num_binary), emb_dim // 2) if num_binary > 0 else None
        in_dim = emb_dim + (emb_dim if self.num_linear else 0) + (emb_dim // 2 if self.bin_linear else 0)

        self.mlp = nn.Sequential(
            nn.Linear(in_dim, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, hidden),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(hidden, emb_dim)
        )

    def forward(self, route_id, route_num, route_bin):
        parts = [self.route_emb(route_id)]
        if self.num_linear:
            if route_num.ndim == 1:
                route_num = route_num.unsqueeze(0)
            parts.append(self.num_linear(route_num))
        if self.bin_linear:
            if route_bin.ndim == 1:
                route_bin = route_bin.unsqueeze(0)
            parts.append(self.bin_linear(route_bin))
        x = torch.cat(parts, dim=1)
        return F.normalize(self.mlp(x), dim=1)

# ==========================
# 3. 체크포인트 불러오기
# ==========================
checkpoint = torch.load(
    "two_tower_no_startnode_gen2.pth",
    map_location="cpu",
    weights_only=False
)

user2idx = checkpoint["user2idx"]
route2idx = checkpoint["route2idx"]
scaler_user = checkpoint["scaler_user"]
scaler_route = checkpoint["scaler_route"]
user_numeric_cols = checkpoint["user_numeric_cols"] # Load from checkpoint
user_binary_cols = checkpoint["user_binary_cols"] # Load from checkpoint
route_numeric_cols = checkpoint["route_numeric_cols"] # Load from checkpoint
route_binary_cols = checkpoint["route_binary_cols"] # Load from checkpoint


# ==========================
# 4. feature 개수 설정 (로드된 정보 사용)
# ==========================
num_numeric_user = len(user_numeric_cols)
num_binary_user  = len(user_binary_cols)
num_numeric_route = len(route_numeric_cols)
num_binary_route  = len(route_binary_cols)

user_vocab = len(user2idx)
route_vocab = len(route2idx)

# ==========================
# 5. 모델 초기화 + 로드
# ==========================
user_tower = UserTower(user_vocab, num_numeric_user, num_binary_user)
route_tower = RouteTower(route_vocab, num_numeric_route, num_binary_route)

user_tower.load_state_dict(checkpoint["user_tower"])
route_tower.load_state_dict(checkpoint["route_tower"])


user_tower.eval()
route_tower.eval()

# ==========================
# 6. 평가 함수 정의
# ==========================
device = "cuda" if torch.cuda.is_available() else "cpu"
def eval_ranking(users_subset, K=100):
    """전체 3.8만 루트 후보에서 Top-K를 뽑아 Hit@K와 Recall@K(정의대로)를 계산."""
    user_tower.eval(); route_tower.eval()
    # 모든 route embedding 1회 계산
    with torch.no_grad():
        # Ensure route_df exists and is accessible
        if 'route_df' not in globals():
            raise NameError("route_df is not defined. Please ensure the cell loading and preprocessing data has been run.")

        all_rid = torch.tensor(route_df["route_id"].values, dtype=torch.long, device=device)
        all_rnum = torch.tensor(route_df[route_numeric_cols].values, dtype=torch.float32, device=device) if route_numeric_cols else torch.zeros((len(route_df),0), device=device)
        all_rbin = torch.tensor(route_df[route_binary_cols].values, dtype=torch.float32, device=device) if route_binary_cols else torch.zeros((len(route_df),0), device=device)
        all_rvec = route_tower(all_rid, all_rnum, all_rbin)  # (N_routes, d)

    hits, recalls = [], []
    with torch.no_grad():
        for uid in users_subset:
            # Ensure user_df and test_pos exist and are accessible
            if 'user_df' not in globals() or 'test_pos' not in globals() or 'valid_pos' not in globals() or 'test_users' not in globals():
                 raise NameError("user_df, test_pos, valid_pos, or test_users are not defined. Please ensure the cells loading and splitting data have been run.")

            # 유저 feature 불러와 벡터 생성
            urow = user_df[user_df["user_id"] == uid].iloc[0]
            unum = torch.tensor(pd.to_numeric(urow[user_numeric_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32, device=device) if user_numeric_cols else torch.zeros(0, device=device)
            ubin = torch.tensor(pd.to_numeric(urow[user_binary_cols], errors="coerce").fillna(0).values,
                                dtype=torch.float32, device=device) if user_binary_cols else torch.zeros(0, device=device)
            uvec = user_tower(torch.tensor([uid], dtype=torch.long, device=device), unum.unsqueeze(0) if unum.ndim==1 else unum, ubin.unsqueeze(0) if ubin.ndim==1 else ubin)  # (1,d)

            # 전체 루트 점수
            scores = torch.matmul(uvec, all_rvec.T).squeeze(0)  # (N_routes,)
            topk_idx = torch.topk(scores, K).indices.detach().tolist()
            # Map indices back to original route_ids if necessary, or use mapped indices consistently
            topk_routes = set([int(idx) for idx in topk_idx])  # idx == route_id (매핑된 index)

            # 정답(그 유저의 Top100; test 또는 valid positive)
            if uid in test_users:
                true_routes = set(test_pos[test_pos["user_id"] == uid]["route_id"].tolist())
            else:
                true_routes = set(valid_pos[valid_pos["user_id"] == uid]["route_id"].tolist())

            # Hit@K (하나라도 맞으면 1)
            hit = 1.0 if len(topk_routes & true_routes) > 0 else 0.0
            hits.append(hit)
            # Recall@K (|교집합| / |정답집합|)
            recalls.append(len(topk_routes & true_routes) / max(1, len(true_routes)))
    return float(np.mean(hits)), float(np.mean(recalls)),topk_routes,true_routes


# ==========================
# 7. 평가 실행 (예시)
# ==========================
# test_users, user_features, route_features 는 학습할 때 쓰던 split/구조와 동일하게 준비해야 함
test_hit, test_recall,topk_routes = eval_ranking(test_users, K=1)
print(f"Final Test Hit@1 = {test_hit:.4f}, Recall@1 = {test_recall:.4f}")
print(topk_routes)

test_hit, test_recall,topk_routes = eval_ranking(test_users, K=10)
print(f"Final Test Hit@10 = {test_hit:.4f}, Recall@10 = {test_recall:.4f}")
print(topk_routes)

test_hit, test_recall,topk_routes = eval_ranking(test_users, K=20)
print(f"Final Test Hit@20 = {test_hit:.4f}, Recall@20 = {test_recall:.4f}")
print(topk_routes)



test_users